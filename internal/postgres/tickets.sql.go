// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tickets.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertSeat = `-- name: InsertSeat :exec
insert into seats (ticket_id, seat_number) values ($1, $2)
`

type InsertSeatParams struct {
	TicketID   int64 `json:"ticketId"`
	SeatNumber int16 `json:"seatNumber"`
}

func (q *Queries) InsertSeat(ctx context.Context, arg InsertSeatParams) error {
	_, err := q.db.Exec(ctx, insertSeat, arg.TicketID, arg.SeatNumber)
	return err
}

const insertTicket = `-- name: InsertTicket :one
insert into tickets (user_id, movie_id, premiere_date, premiere_time) values ($1, $2, $3, $4) returning id
`

type InsertTicketParams struct {
	UserID       int64              `json:"userId"`
	MovieID      int64              `json:"movieId"`
	PremiereDate pgtype.Date        `json:"premiereDate"`
	PremiereTime pgtype.Timestamptz `json:"premiereTime"`
}

func (q *Queries) InsertTicket(ctx context.Context, arg InsertTicketParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertTicket,
		arg.UserID,
		arg.MovieID,
		arg.PremiereDate,
		arg.PremiereTime,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const selectTicket = `-- name: SelectTicket :one
select 
    m.id			as movie_id				,
    m.name 			as movie_name			,
    m.movie_time 	as movie_time			,
    m.genres 		as movie_genres			,
    t.reserved_at 	as reserved_at			,
    t.premiere_date as premiere_date		,
    t.premiere_time as premiere_time		,
    array_agg(s.seat_number)::int2[] as reserved_seats
from
    tickets t
    left join seats s on s.ticket_id = t.id
    inner join movies m on m.id = t.movie_id
where 
    t.id = $1
    and t.user_id = $2
group by
    t.id, m.id
`

type SelectTicketParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"userId"`
}

type SelectTicketRow struct {
	MovieID       int64              `json:"movieId"`
	MovieName     string             `json:"movieName"`
	MovieTime     int16              `json:"movieTime"`
	MovieGenres   []string           `json:"movieGenres"`
	ReservedAt    pgtype.Timestamptz `json:"reservedAt"`
	PremiereDate  pgtype.Date        `json:"premiereDate"`
	PremiereTime  pgtype.Timestamptz `json:"premiereTime"`
	ReservedSeats []int16            `json:"reservedSeats"`
}

func (q *Queries) SelectTicket(ctx context.Context, arg SelectTicketParams) (SelectTicketRow, error) {
	row := q.db.QueryRow(ctx, selectTicket, arg.ID, arg.UserID)
	var i SelectTicketRow
	err := row.Scan(
		&i.MovieID,
		&i.MovieName,
		&i.MovieTime,
		&i.MovieGenres,
		&i.ReservedAt,
		&i.PremiereDate,
		&i.PremiereTime,
		&i.ReservedSeats,
	)
	return i, err
}

const selectUserTickets = `-- name: SelectUserTickets :many
select 
    m.id 			as movie_id		,
    t.id 			as ticket_id	,
    m.name 			as movie_name	,
    t.premiere_date as premiere_date,
    t.premiere_time as premiere_time
from
    tickets t
    join movies m on m.id = t.movie_id
where 
    t.user_id = $1
order by
    reserved_at desc
`

type SelectUserTicketsRow struct {
	MovieID      int64              `json:"movieId"`
	TicketID     int64              `json:"ticketId"`
	MovieName    string             `json:"movieName"`
	PremiereDate pgtype.Date        `json:"premiereDate"`
	PremiereTime pgtype.Timestamptz `json:"premiereTime"`
}

func (q *Queries) SelectUserTickets(ctx context.Context, userID int64) ([]SelectUserTicketsRow, error) {
	rows, err := q.db.Query(ctx, selectUserTickets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectUserTicketsRow{}
	for rows.Next() {
		var i SelectUserTicketsRow
		if err := rows.Scan(
			&i.MovieID,
			&i.TicketID,
			&i.MovieName,
			&i.PremiereDate,
			&i.PremiereTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
